from PyQt6 import QtWidgets, uic
from PyQt6.QtWidgets import QApplication, QTableWidgetItem, QHeaderView, QMessageBox
import sys
import os
import pyodbc
from datetime import datetime, timedelta

# --- Database Connection Details ---
server = 'localhost'
database = 'Cinema_booking_system'
use_windows_authentication = True
username = 'your_username'
password = 'your_password'

# Set up scaling
os.environ["QT_AUTO_SCREEN_SCALE_FACTOR"] = "0.5"
os.environ["QT_ENABLE_HIGHDPI_SCALING"] = "1"
os.environ["QT_SCALE_FACTOR"] = "1.3"


def create_connection_string():
    if use_windows_authentication:
        return (
            f'DRIVER={{ODBC Driver 17 for SQL Server}};'
            f'SERVER={server};'
            f'DATABASE={database};'
            f'Trusted_Connection=yes;'
        )
    else:
        return (
            f'DRIVER={{ODBC Driver 17 for SQL Server}};'
            f'SERVER={server};'
            f'DATABASE={database};'
            f'UID={username};'
            f'PWD={password};'
        )


# ==================== MAIN WINDOW ====================
class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()

        try:
            self.ui = uic.loadUi("newmovie.ui")
            self.setCentralWidget(self.ui)
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load newmovie.ui.\nError: {e}")
            sys.exit(1)

        # Buttons
        try:
            self.ui.manageButton.clicked.connect(self.open_manage_bookings)
        except:
            print("Error: 'manageButton' not found!")

        # Combos
        try:
            self.branch_combo = self.ui.branch_combo
            self.load_branch_names()
        except:
            print("Error: 'branch_combo' not found!")

        try:
            self.movie_combo = self.ui.movie_combo
            self.load_active_movies()
        except:
            print("Error: 'movie_combo' not found!")

        try:
            self.date_combo = self.ui.date_combo
            self.load_date_dropdown()
        except:
            print("Error: 'date_combo' not found!")

        # Navigation
        try:
            self.book_next_button = self.ui.book_next
            self.book_next_button.clicked.connect(self.open_booking_window)
        except:
            print("Error: 'book_next' not found!")

    def load_branch_names(self):
        conn_str = create_connection_string()
        try:
            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            cursor.execute("SELECT BranchName FROM Cinema ORDER BY BranchName;")
            branches = cursor.fetchall()
            self.branch_combo.clear()
            self.branch_combo.addItem("Select Branch")
            for b in branches:
                self.branch_combo.addItem(b[0])
            self.branch_combo.setCurrentIndex(0)
            cursor.close()
            conn.close()
        except Exception as e:
            print("Branch load error:", e)
            self.branch_combo.clear()
            self.branch_combo.addItem("Error")

    def load_active_movies(self):
        conn_str = create_connection_string()
        try:
            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            cursor.execute("SELECT Movie_Name FROM Movies WHERE Is_Active = 1 ORDER BY Movie_Name;")
            movies = cursor.fetchall()
            self.movie_combo.clear()
            self.movie_combo.addItem("Select Movie")
            for m in movies:
                self.movie_combo.addItem(m[0])
            self.movie_combo.setCurrentIndex(0)
            cursor.close()
            conn.close()
        except Exception as e:
            print("Movie load error:", e)
            self.movie_combo.clear()
            self.movie_combo.addItem("Error")

    def load_date_dropdown(self):
        self.date_combo.clear()
        self.date_combo.addItem("Select Date")
        today = datetime.today()
        for i in range(8):
            date_str = (today + timedelta(days=i)).strftime("%Y-%m-%d")
            self.date_combo.addItem(date_str)
        self.date_combo.setCurrentIndex(0)

    def open_booking_window(self):
        if self.branch_combo.currentIndex() == 0:
            QMessageBox.warning(self, "Required", "Please select a Branch.")
            return
        if self.movie_combo.currentIndex() == 0:
            QMessageBox.warning(self, "Required", "Please select a Movie.")
            return
        if self.date_combo.currentIndex() == 0:
            QMessageBox.warning(self, "Required", "Please select a Date.")
            return

        try:
            self.booking_window = BookingWindow(
                selected_movie=self.movie_combo.currentText(),
                selected_date=self.date_combo.currentText(),
                selected_branch=self.branch_combo.currentText()
            )
            self.booking_window.show()
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load booking.ui.\nError: {e}")

    def open_manage_bookings(self):
        self.manage_bookings = ManageWindow()
        self.manage_bookings.show()


# ==================== RECORDS CUSTOMER WINDOW ====================
class RecordsCustomerWindow(QtWidgets.QMainWindow):
    def __init__(self, customer_name="", customer_email=""):
        super().__init__()

        try:
            uic.loadUi("records_customer.ui", self)
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load records_customer.ui.\nError: {e}")
            sys.exit(1)

        self.customer_name = customer_name
        self.customer_email = customer_email
        self.has_data = False

        self.recordsTable = self.findChild(QtWidgets.QTableWidget, "recordsTable")
        self.returnButton = self.findChild(QtWidgets.QPushButton, "returnButton")
        if self.returnButton:
            self.returnButton.clicked.connect(self.close)
        self.cancelButton = self.findChild(QtWidgets.QPushButton, "cancelButton")
        if self.cancelButton:
            self.cancelButton.clicked.connect(self.cancel_booking)

        self.load_customer_bookings()

    def load_customer_bookings(self):
        if not self.recordsTable:
            return
        
        conn_str = create_connection_string()
        try:
            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            
            # Build the query - using Tickets table
            query = """
            SELECT 
                C.Customer_Name, 
                B.BookingID, 
                M.Movie_Name, 
                T.Date, 
                B.Time, 
                B.No_Of_Tickets,
                T.Booking_Status
            FROM 
                Customer C
                JOIN Bookings B ON C.Customer_Email = B.Customer_Email
                JOIN Movies M ON B.Movie_Name = M.Movie_Name
                JOIN Tickets T ON B.BookingID = T.BookingID
            WHERE 1=1
            """
            
            params = []
            
            # Add conditions based on the inputs
            if self.customer_name:
                query += " AND C.Customer_Name = ?"
                params.append(self.customer_name)
            
            if self.customer_email:
                query += " AND C.Customer_Email = ?"
                params.append(self.customer_email)
            
            query += " ORDER BY T.Date DESC, B.Time DESC;"
            
            # Execute query
            cursor.execute(query, params)
            data = cursor.fetchall()
            
            # Close connection
            cursor.close()
            conn.close()

            if not data:
                QMessageBox.information(self, "No Records", 
                                       "No bookings found for the given customer details.")
                self.has_data = False
                return

            # Prepare the table for data
            self.has_data = True
            headers = ["Customer Name", "Booking ID", "Movie", "Date", "Time", "No of tickets", "Booking status"]
            self.recordsTable.setColumnCount(len(headers))
            self.recordsTable.setHorizontalHeaderLabels(headers)
            self.recordsTable.setRowCount(len(data))
            
            # Populate table rows
            for row_index, row_data in enumerate(data):
                for col_index, item in enumerate(row_data):
                    # Format datetime fields
                    if col_index == 3:  # Date column
                        if hasattr(item, 'strftime'):
                            item_str = item.strftime("%Y-%m-%d")
                        else:
                            item_str = str(item) if item is not None else ""
                    elif col_index == 4:  # Time column
                        if hasattr(item, 'strftime'):
                            item_str = item.strftime("%H:%M")
                        else:
                            item_str = str(item) if item is not None else ""
                    else:
                        item_str = str(item) if item is not None else ""
                    
                    self.recordsTable.setItem(row_index, col_index, QTableWidgetItem(item_str))

            # Auto-resize columns
            self.recordsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
            # Make the 'Movie' column expand to fill available space
            self.recordsTable.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)

        except pyodbc.Error as ex:
            sqlstate = ex.args[0] if ex.args else "Unknown"
            QMessageBox.critical(self, "Database Error", 
                                 f"Could not connect to the database or run query.\nError: {sqlstate}")
        except Exception as e:
            QMessageBox.critical(self, "Application Error", 
                                 f"An unexpected error occurred during data loading: {e}")

    def cancel_booking(self):
        """Cancels the selected booking."""
        selected_row = self.recordsTable.currentRow()
        
        if selected_row < 0:
            QMessageBox.warning(self, "No Selection", "Please select a booking to cancel.")
            return
        
        # Get the Booking ID from the selected row
        booking_id_item = self.recordsTable.item(selected_row, 1)
        if not booking_id_item:
            QMessageBox.warning(self, "Error", "Could not read Booking ID from selected row.")
            return
        
        booking_id = booking_id_item.text()
        
        # Get the current booking status
        status_item = self.recordsTable.item(selected_row, 6)
        current_status = status_item.text() if status_item else "Unknown"
        
        # Check if already cancelled
        if current_status.lower() == 'cancelled':
            QMessageBox.information(self, "Already Cancelled", 
                                   f"Booking ID {booking_id} is already cancelled.")
            return
        
        # Confirm cancellation
        reply = QMessageBox.question(self, "Confirm Cancellation",
                                     f"Are you sure you want to cancel Booking ID: {booking_id}?",
                                     QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        
        if reply != QMessageBox.StandardButton.Yes:
            return
        
        # Update the booking status in the database
        conn_str = create_connection_string()
        try:
            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            
            # Update the Tickets table
            update_query = """
            UPDATE Tickets
            SET Booking_Status = 'Cancelled'
            WHERE BookingID = ?
            """
            
            cursor.execute(update_query, (booking_id,))
            rows_affected = cursor.rowcount
            conn.commit()
            
            cursor.close()
            conn.close()
            
            if rows_affected > 0:
                QMessageBox.information(self, "Success", 
                                       f"Booking {booking_id} has been cancelled successfully.")
                # Reload the table to show updated status
                self.load_customer_bookings()
            else:
                QMessageBox.warning(self, "Update Failed", 
                                   f"No rows were updated. Booking ID {booking_id} might not exist in Tickets table.")
            
        except pyodbc.Error as ex:
            sqlstate = ex.args[0] if ex.args else "Unknown error"
            QMessageBox.critical(self, "Database Error", 
                                 f"Could not cancel booking.\nError: {sqlstate}")
        except Exception as e:
            QMessageBox.critical(self, "Application Error", 
                                 f"An error occurred: {e}")


# ==================== MANAGE BOOKINGS WINDOW ====================
class ManageWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        try:
            self.ui = uic.loadUi("manage_bookings.ui")
            self.setCentralWidget(self.ui)
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load manage_bookings.ui.\nError: {e}")
            sys.exit(1)

        try:
            self.bookingsTable = self.ui.bookingsTable
        except:
            print("Error: bookingsTable not found!")

        try:
            self.ui.book_return.clicked.connect(self.close)
        except:
            print("Error: book_return not found!")

        self.load_booking_data()

        # Search for customer records
        try:
            self.nameInput = self.ui.name_input
            self.emailInput = self.ui.email_input
            self.ui.next_button.clicked.connect(self.open_records_customer)
        except:
            print("Error: name/email inputs or next_button not found!")

    def load_booking_data(self):
        if not hasattr(self, "bookingsTable") or self.bookingsTable is None:
            return
        conn_str = create_connection_string()
        try:
            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            cursor.execute("""
            SELECT
                B.BookingID,
                C.Customer_Name,
                M.Movie_Name,
                B.Time,
                B.No_Of_Tickets,
                B.Mode_Of_Payment
            FROM Bookings B
            JOIN Customer C ON B.Customer_Email = C.Customer_Email
            JOIN Movies M ON B.Movie_Name = M.Movie_Name
            ORDER BY B.BookingID;
            """)
            data = cursor.fetchall()
            cursor.close()
            conn.close()

            headers = ["Booking ID", "Customer Name", "Movie", "Show Time", "Tickets", "Payment Mode"]
            self.bookingsTable.setColumnCount(len(headers))
            self.bookingsTable.setHorizontalHeaderLabels(headers)
            self.bookingsTable.setRowCount(len(data))
            for r, row in enumerate(data):
                for c, item in enumerate(row):
                    if c == 3 and hasattr(item, "strftime"):
                        item = item.strftime("%Y-%m-%d %H:%M")
                    self.bookingsTable.setItem(r, c, QTableWidgetItem(str(item)))
            self.bookingsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
            self.bookingsTable.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        except Exception as e:
            print("Booking table load error:", e)

    def open_records_customer(self):
        customer_name = self.nameInput.text().strip() if self.nameInput else ""
        customer_email = self.emailInput.text().strip() if self.emailInput else ""
        if not customer_name and not customer_email:
            QMessageBox.warning(self, "Input Required", "Enter Name or Email to search.")
            return
        self.records_customer_window = RecordsCustomerWindow(customer_name, customer_email)
        if self.records_customer_window.has_data:
            self.records_customer_window.show()
        else:
            self.records_customer_window.deleteLater()


# ==================== APPLICATION EXECUTION ====================
def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()

# from PyQt6 import QtWidgets, uic
# from PyQt6.QtWidgets import QApplication, QTableWidgetItem, QHeaderView, QMessageBox
# import sys
# import os
# import pyodbc
# from datetime import datetime, timedelta

# # --- Database Connection Details ---
# server = 'localhost'
# database = 'Cinema_booking_system'
# use_windows_authentication = True
# username = 'sa'
# password = 'your_password'

# # Set up scaling
# os.environ["QT_AUTO_SCREEN_SCALE_FACTOR"] = "0.5"
# os.environ["QT_ENABLE_HIGHDPI_SCALING"] = "1"
# os.environ["QT_SCALE_FACTOR"] = "1.3"


# def create_connection_string():
#     if use_windows_authentication:
#         return (
#             f'DRIVER={{ODBC Driver 17 for SQL Server}};'
#             f'SERVER={server};'
#             f'DATABASE={database};'
#             f'Trusted_Connection=yes;'
#         )
#     else:
#         return (
#             f'DRIVER={{ODBC Driver 17 for SQL Server}};'
#             f'SERVER={server};'
#             f'DATABASE={database};'
#             f'UID={username};'
#             f'PWD={password};'
#         )


# # ==================== MAIN WINDOW ====================
# class MainWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()

#         try:
#             self.ui = uic.loadUi("newmovie.ui")
#             self.setCentralWidget(self.ui)
#         except Exception as e:
#             QMessageBox.critical(self, "UI Load Error", f"Could not load newmovie.ui.\nError: {e}")
#             sys.exit(1)

#         # Buttons
#         try:
#             self.ui.manageButton.clicked.connect(self.open_manage_bookings)
#         except:
#             print("Error: 'manageButton' not found!")

#         # Combos
#         try:
#             self.branch_combo = self.ui.branch_combo
#             self.load_branch_names()
#         except:
#             print("Error: 'branch_combo' not found!")

#         try:
#             self.movie_combo = self.ui.movie_combo
#             self.load_active_movies()
#         except:
#             print("Error: 'movie_combo' not found!")

#         try:
#             self.date_combo = self.ui.date_combo
#             self.load_date_dropdown()
#         except:
#             print("Error: 'date_combo' not found!")

#         # Navigation
#         try:
#             self.book_next_button = self.ui.book_next
#             self.book_next_button.clicked.connect(self.open_booking_window)
#         except:
#             print("Error: 'book_next' not found!")

#     def load_branch_names(self):
#         conn_str = create_connection_string()
#         try:
#             conn = pyodbc.connect(conn_str)
#             cursor = conn.cursor()
#             cursor.execute("SELECT BranchName FROM Cinema ORDER BY BranchName;")
#             branches = cursor.fetchall()
#             self.branch_combo.clear()
#             self.branch_combo.addItem("Select Branch")
#             for b in branches:
#                 self.branch_combo.addItem(b[0])
#             self.branch_combo.setCurrentIndex(0)
#             cursor.close()
#             conn.close()
#         except Exception as e:
#             print("Branch load error:", e)
#             self.branch_combo.clear()
#             self.branch_combo.addItem("Error")

#     def load_active_movies(self):
#         conn_str = create_connection_string()
#         try:
#             conn = pyodbc.connect(conn_str)
#             cursor = conn.cursor()
#             cursor.execute("SELECT Movie_Name FROM Movies WHERE Is_Active = 1 ORDER BY Movie_Name;")
#             movies = cursor.fetchall()
#             self.movie_combo.clear()
#             self.movie_combo.addItem("Select Movie")
#             for m in movies:
#                 self.movie_combo.addItem(m[0])
#             self.movie_combo.setCurrentIndex(0)
#             cursor.close()
#             conn.close()
#         except Exception as e:
#             print("Movie load error:", e)
#             self.movie_combo.clear()
#             self.movie_combo.addItem("Error")

#     def load_date_dropdown(self):
#         self.date_combo.clear()
#         self.date_combo.addItem("Select Date")
#         today = datetime.today()
#         for i in range(8):
#             date_str = (today + timedelta(days=i)).strftime("%Y-%m-%d")
#             self.date_combo.addItem(date_str)
#         self.date_combo.setCurrentIndex(0)

#     def open_booking_window(self):
#         if self.branch_combo.currentIndex() == 0:
#             QMessageBox.warning(self, "Required", "Please select a Branch.")
#             return
#         if self.movie_combo.currentIndex() == 0:
#             QMessageBox.warning(self, "Required", "Please select a Movie.")
#             return
#         if self.date_combo.currentIndex() == 0:
#             QMessageBox.warning(self, "Required", "Please select a Date.")
#             return

#         try:
#             self.booking_window = BookingWindow(
#                 selected_movie=self.movie_combo.currentText(),
#                 selected_date=self.date_combo.currentText(),
#                 selected_branch=self.branch_combo.currentText()
#             )
#             self.booking_window.show()
#         except Exception as e:
#             QMessageBox.critical(self, "UI Load Error", f"Could not load booking.ui.\nError: {e}")

#     def open_manage_bookings(self):
#         self.manage_bookings = ManageWindow()
#         self.manage_bookings.show()


# # ==================== BOOKING & PAYMENT WINDOWS ====================
# # (Keep your previous BookingWindow, NoOfTicketsWindow, PaymentWindow as is)
# # I will just not repeat them here to save space; use your original classes.


# # ==================== MANAGE BOOKINGS + RECORDS CUSTOMER ====================
# class RecordsCustomerWindow(QtWidgets.QMainWindow):
#     def __init__(self, customer_name="", customer_email=""):
#         super().__init__()

#         try:
#             uic.loadUi("records_customer.ui", self)
#         except Exception as e:
#             QMessageBox.critical(self, "UI Load Error", f"Could not load records_customer.ui.\nError: {e}")
#             sys.exit(1)

#         self.customer_name = customer_name
#         self.customer_email = customer_email
#         self.has_data = False

#         self.recordsTable = self.findChild(QtWidgets.QTableWidget, "recordsTable")
#         self.returnButton = self.findChild(QtWidgets.QPushButton, "returnButton")
#         if self.returnButton:
#             self.returnButton.clicked.connect(self.close)
#         self.cancelButton = self.findChild(QtWidgets.QPushButton, "cancelButton")
#         if self.cancelButton:
#             self.cancelButton.clicked.connect(self.cancel_booking)

#         self.load_customer_bookings()

#     def load_customer_bookings(self):
#         if not self.recordsTable:
#             return
#         conn_str = create_connection_string()
#         try:
#             conn = pyodbc.connect(conn_str)
#             cursor = conn.cursor()
#             query = """
#             SELECT 
#                 C.Customer_Name, 
#                 B.BookingID, 
#                 M.Movie_Name, 
#                 B.Time, 
#                 B.No_Of_Tickets,
#                 B.Mode_Of_Payment
#             FROM 
#                 Customer C
#                 JOIN Bookings B ON C.Customer_Email = B.Customer_Email
#                 JOIN Movies M ON B.Movie_Name = M.Movie_Name
#             WHERE 1=1
#             """
#             params = []
#             if self.customer_name:
#                 query += " AND C.Customer_Name = ?"
#                 params.append(self.customer_name)
#             if self.customer_email:
#                 query += " AND C.Customer_Email = ?"
#                 params.append(self.customer_email)
#             query += " ORDER BY B.Time DESC;"
#             cursor.execute(query, params)
#             data = cursor.fetchall()
#             cursor.close()
#             conn.close()

#             if not data:
#                 QMessageBox.information(self, "No Records", "No bookings found for this customer.")
#                 self.has_data = False
#                 return

#             self.has_data = True
#             headers = ["Customer Name", "Booking ID", "Movie", "Show Time", "Tickets", "Payment Mode"]
#             self.recordsTable.setColumnCount(len(headers))
#             self.recordsTable.setHorizontalHeaderLabels(headers)
#             self.recordsTable.setRowCount(len(data))
#             for r, row in enumerate(data):
#                 for c, item in enumerate(row):
#                     if c == 3 and hasattr(item, "strftime"):
#                         item = item.strftime("%Y-%m-%d %H:%M")
#                     self.recordsTable.setItem(r, c, QTableWidgetItem(str(item)))
#             self.recordsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
#             self.recordsTable.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)

#         except Exception as e:
#             QMessageBox.critical(self, "DB Error", f"Could not load customer bookings.\nError: {e}")

#     def cancel_booking(self):
#         selected_row = self.recordsTable.currentRow()
#         if selected_row < 0:
#             QMessageBox.warning(self, "No Selection", "Please select a booking to cancel.")
#             return
#         booking_id_item = self.recordsTable.item(selected_row, 1)
#         if not booking_id_item:
#             QMessageBox.warning(self, "Error", "Could not read Booking ID.")
#             return
#         booking_id = booking_id_item.text()

#         reply = QMessageBox.question(self, "Confirm Cancellation",
#                                      f"Are you sure you want to cancel Booking ID: {booking_id}?",
#                                      QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
#         if reply != QMessageBox.StandardButton.Yes:
#             return

#         try:
#             conn = pyodbc.connect(create_connection_string())
#             cursor = conn.cursor()
#             cursor.execute("UPDATE Bookings SET Mode_Of_Payment='Cancelled' WHERE BookingID=?", booking_id)
#             conn.commit()
#             cursor.close()
#             conn.close()
#             QMessageBox.information(self, "Cancelled", f"Booking {booking_id} cancelled successfully.")
#             self.load_customer_bookings()
#         except Exception as e:
#             QMessageBox.critical(self, "DB Error", f"Could not cancel booking.\nError: {e}")


# class ManageWindow(QtWidgets.QMainWindow):
#     def __init__(self):
#         super().__init__()
#         try:
#             self.ui = uic.loadUi("manage_bookings.ui")
#             self.setCentralWidget(self.ui)
#         except Exception as e:
#             QMessageBox.critical(self, "UI Load Error", f"Could not load manage_bookings.ui.\nError: {e}")
#             sys.exit(1)

#         try:
#             self.bookingsTable = self.ui.bookingsTable
#         except:
#             print("Error: bookingsTable not found!")

#         try:
#             self.ui.book_return.clicked.connect(self.close)
#         except:
#             print("Error: book_return not found!")

#         self.load_booking_data()

#         # Search for customer records
#         try:
#             self.nameInput = self.ui.name_input
#             self.emailInput = self.ui.email_input
#             self.ui.next_button.clicked.connect(self.open_records_customer)
#         except:
#             print("Error: name/email inputs or next_button not found!")

#     def load_booking_data(self):
#         if not hasattr(self, "bookingsTable"):
#             return
#         conn_str = create_connection_string()
#         try:
#             conn = pyodbc.connect(conn_str)
#             cursor = conn.cursor()
#             cursor.execute("""
#             SELECT
#                 B.BookingID,
#                 C.Customer_Name,
#                 M.Movie_Name,
#                 B.Time,
#                 B.No_Of_Tickets,
#                 B.Mode_Of_Payment
#             FROM Bookings B
#             JOIN Customer C ON B.Customer_Email = C.Customer_Email
#             JOIN Movies M ON B.Movie_Name = M.Movie_Name
#             ORDER BY B.BookingID;
#             """)
#             data = cursor.fetchall()
#             cursor.close()
#             conn.close()

#             headers = ["ID", "Customer Name", "Movie Name", "Show Time", "Tickets", "Payment"]
#             self.bookingsTable.setColumnCount(len(headers))
#             self.bookingsTable.setHorizontalHeaderLabels(headers)
#             self.bookingsTable.setRowCount(len(data))
#             for r, row in enumerate(data):
#                 for c, item in enumerate(row):
#                     if c == 3 and hasattr(item, "strftime"):
#                         item = item.strftime("%Y-%m-%d %H:%M")
#                     self.bookingsTable.setItem(r, c, QTableWidgetItem(str(item)))
#             self.bookingsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
#             self.bookingsTable.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
#         except Exception as e:
#             print("Booking table load error:", e)

#     def open_records_customer(self):
#         customer_name = self.nameInput.text().strip() if self.nameInput else ""
#         customer_email = self.emailInput.text().strip() if self.emailInput else ""
#         if not customer_name and not customer_email:
#             QMessageBox.warning(self, "Input Required", "Enter Name or Email to search.")
#             return
#         self.records_customer_window = RecordsCustomerWindow(customer_name, customer_email)
#         if self.records_customer_window.has_data:
#             self.records_customer_window.show()
#         else:
#             self.records_customer_window.deleteLater()


# # ==================== APPLICATION EXECUTION ====================
# def main():
#     app = QApplication(sys.argv)
#     window = MainWindow()
#     window.show()
#     sys.exit(app.exec())


# if __name__ == "__main__":
#     main()