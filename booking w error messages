from PyQt6 import QtWidgets, uic
from PyQt6.QtWidgets import QApplication, QTableWidgetItem, QHeaderView, QMessageBox
import sys
import os
import pyodbc
from datetime import datetime, timedelta

# --- Database Connection Details ---
server = 'localhost\\SQLSERVER1'
database = 'project'
use_windows_authentication = True
username = 'sa'
password = 'your_password'

# Set up scaling
os.environ["QT_AUTO_SCREEN_SCALE_FACTOR"] = "0.5"
os.environ["QT_ENABLE_HIGHDPI_SCALING"] = "1"
os.environ["QT_SCALE_FACTOR"] = "1.3"

def create_connection_string():
    if use_windows_authentication:
        return (
            f'DRIVER={{ODBC Driver 17 for SQL Server}};'
            f'SERVER={server};'
            f'DATABASE={database};'
            f'Trusted_Connection=yes;'
        )
    else:
        return (
            f'DRIVER={{ODBC Driver 17 for SQL Server}};'
            f'SERVER={server};'
            f'DATABASE={database};'
            f'UID={username};'
            f'PWD={password};'
        )

# ==================== MAIN WINDOW ====================

class MainWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()

        try:
            self.ui = uic.loadUi("newmovie.ui")
            self.setCentralWidget(self.ui)
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load newmovie.ui.\nError: {e}")
            sys.exit(1)

        try:
            self.ui.manageButton.clicked.connect(self.open_manage_bookings)
        except:
            print("Error: 'manageButton' not found!")

        try:
            self.branch_combo = self.ui.branch_combo
            self.load_branch_names()
        except:
            print("Error: 'branch_combo' not found!")

        try:
            self.movie_combo = self.ui.movie_combo
            self.load_active_movies()
        except:
            print("Error: 'movie_combo' not found!")

        try:
            self.date_combo = self.ui.date_combo
            self.load_date_dropdown()
        except:
            print("Error: 'date_combo' not found!")

        try:
            self.book_next_button = self.ui.book_next
            self.book_next_button.clicked.connect(self.open_booking_window)
        except:
            print("Error: 'book_next' not found!")

    def load_branch_names(self):
        conn_str = create_connection_string()
        try:
            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            query = "SELECT BranchName FROM Cinema ORDER BY BranchName;"
            cursor.execute(query)
            branches = cursor.fetchall()
            self.branch_combo.clear()
            self.branch_combo.addItem("Select Branch")
            for b in branches:
                self.branch_combo.addItem(b[0])
            self.branch_combo.setCurrentIndex(0)
            cursor.close()
            conn.close()
        except Exception as e:
            print("Branch load error:", e)
            self.branch_combo.clear()
            self.branch_combo.addItem("Error")

    def load_active_movies(self):
        conn_str = create_connection_string()
        try:
            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            query = "SELECT Movie_Name FROM Movies WHERE Is_Active = 1 ORDER BY Movie_Name;"
            cursor.execute(query)
            movies = cursor.fetchall()
            self.movie_combo.clear()
            self.movie_combo.addItem("Select Movie")
            for m in movies:
                self.movie_combo.addItem(m[0])
            self.movie_combo.setCurrentIndex(0)
            cursor.close()
            conn.close()
        except Exception as e:
            print("Movie load error:", e)
            self.movie_combo.clear()
            self.movie_combo.addItem("Error")

    def load_date_dropdown(self):
        self.date_combo.clear()
        self.date_combo.addItem("Select Date")
        today = datetime.today()
        for i in range(8):
            date_str = (today + timedelta(days=i)).strftime("%Y-%m-%d")
            self.date_combo.addItem(date_str)
        self.date_combo.setCurrentIndex(0)

    def open_booking_window(self):
        if self.branch_combo.currentIndex() == 0:
            QMessageBox.warning(self, "Required", "Please select a Branch.")
            return
        if self.movie_combo.currentIndex() == 0:
            QMessageBox.warning(self, "Required", "Please select a Movie.")
            return
        if self.date_combo.currentIndex() == 0:
            QMessageBox.warning(self, "Required", "Please select a Date.")
            return

        try:
            self.booking_window = BookingWindow()
            self.booking_window.show()
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load booking.ui.\nError: {e}")

    def open_manage_bookings(self):
        self.manage_bookings = ManageWindow()
        self.manage_bookings.show()

# ==================== BOOKING WINDOW ====================

class BookingWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        try:
            self.ui = uic.loadUi("booking.ui")
            self.setCentralWidget(self.ui)
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load booking.ui.\nError: {e}")
            sys.exit(1)

        for btn in ['book_2', 'book_5', 'book_9']:
            try:
                getattr(self.ui, btn).clicked.connect(self.open_no_of_tickets_window)
            except:
                print(f"Error: {btn} not found!")

    def open_no_of_tickets_window(self):
        try:
            self.no_tickets_window = NoOfTicketsWindow()
            self.no_tickets_window.show()
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load no_of_tickets.ui.\nError: {e}")

# ==================== NO OF TICKETS WINDOW ====================

class NoOfTicketsWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        try:
            self.ui = uic.loadUi("no_of_tickets.ui")
            self.setCentralWidget(self.ui)
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load no_of_tickets.ui.\nError: {e}")
            sys.exit(1)

        self.ticket_line = self.ui.ticket_line
        try:
            self.ui.proceed_pay.clicked.connect(self.open_payment_window)
        except:
            print("Error: proceed_pay not found!")

    def open_payment_window(self):
        tickets = self.ticket_line.text().strip()
        if tickets == "":
            QMessageBox.warning(self, "Missing Input", "Please enter number of tickets.")
            return
        if not tickets.isdigit():
            QMessageBox.warning(self, "Invalid", "Tickets must be a number.")
            return
        try:
            self.payment_window = PaymentWindow()
            self.payment_window.show()
        except Exception as e:
            QMessageBox.critical(self, "UI Error", f"Could not load payment.ui\nError: {e}")

# ==================== PAYMENT WINDOW ====================

class PaymentWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        try:
            self.ui = uic.loadUi("payment.ui")
            self.setCentralWidget(self.ui)
        except Exception as e:
            QMessageBox.critical(self, "UI Error", f"Could not load payment.ui\nError: {e}")
            sys.exit(1)

        # LineEdits
        self.pay_name = getattr(self.ui, "pay_name", None)
        self.pay_contact = getattr(self.ui, "pay_contact", None)
        self.pay_mail = getattr(self.ui, "pay_mail", None)

        # ComboBox
        self.pay_combo = getattr(self.ui, "pay_combo", None)
        # self.pay_combo.setEditable(False)
        self.pay_combo.clear()
        self.pay_combo.addItems(["Select Payment Mode", "Cash", "Card"])
        self.pay_combo.setCurrentIndex(0)

        # Buttons
        self.pay_next_btn = getattr(self.ui, "pay_next", None)
        self.pay_return_btn = getattr(self.ui, "pay_return", None)

        if self.pay_next_btn:
            self.pay_next_btn.clicked.connect(self.go_to_ticket_screen)
        if self.pay_return_btn:
            self.pay_return_btn.clicked.connect(self.confirm_return)

    def go_to_ticket_screen(self):
        # Validate payment fields
        name = self.pay_name.text().strip() if self.pay_name else ""
        contact = self.pay_contact.text().strip() if self.pay_contact else ""
        mail = self.pay_mail.text().strip() if self.pay_mail else ""
        mode = self.pay_combo.currentText() if self.pay_combo else "Select Payment Mode"

        if name == "" or contact == "" or mail == "":
            QMessageBox.warning(self, "Missing Input", "Please fill all fields.")
            return
        if mode == "Select Payment Mode":
            QMessageBox.warning(self, "Missing Input", "Please select payment mode.")
            return

        # Open ticket window
        try:
            self.ticket_window = uic.loadUi("ticket.ui")  # keep reference
            self.ticket_window.show()
        except Exception as e:
            QMessageBox.critical(self, "UI Error", f"Could not load ticket.ui\nError: {e}")

    def confirm_return(self):
        reply = QMessageBox.question(
            self,
            "Cancel Payment",
            "Are you sure you want to cancel payment?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        if reply == QMessageBox.StandardButton.Yes:
            self.close()

# ==================== MANAGE BOOKINGS WINDOW ====================

class ManageWindow(QtWidgets.QMainWindow):
    def __init__(self):
        super().__init__()
        try:
            self.ui = uic.loadUi("manage_bookings.ui")
            self.setCentralWidget(self.ui)
        except Exception as e:
            QMessageBox.critical(self, "UI Load Error", f"Could not load manage_bookings.ui.\nError: {e}")
            sys.exit(1)

        try:
            self.bookingsTable = self.ui.bookingsTable
        except:
            print("Error: bookingsTable not found!")

        try:
            self.ui.book_return.clicked.connect(self.close)
        except:
            print("Error: book_return not found!")

        self.load_booking_data()

    def load_booking_data(self):
        if not hasattr(self, "bookingsTable"):
            return
        conn_str = create_connection_string()
        try:
            conn = pyodbc.connect(conn_str)
            cursor = conn.cursor()
            query = """
            SELECT
                B.BookingID,
                C.Customer_Name,
                M.Movie_Name,
                B.[Time],
                B.No_Of_Tickets,
                B.Mode_Of_Payment
            FROM Bookings B
            JOIN Customer C ON B.Customer_Email = C.Customer_Email
            JOIN Movies M ON B.Movie_Name = M.Movie_Name
            ORDER BY B.BookingID;
            """
            cursor.execute(query)
            data = cursor.fetchall()
            cursor.close()
            conn.close()

            headers = ["ID", "Customer Name", "Movie Name", "Show Time", "Tickets", "Payment"]
            self.bookingsTable.setColumnCount(len(headers))
            self.bookingsTable.setHorizontalHeaderLabels(headers)
            self.bookingsTable.setRowCount(len(data))
            for r, row in enumerate(data):
                for c, item in enumerate(row):
                    if c == 3:
                        item = item.strftime("%Y-%m-%d %H:%M")
                    self.bookingsTable.setItem(r, c, QTableWidgetItem(str(item)))
            self.bookingsTable.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.ResizeToContents)
            self.bookingsTable.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
        except Exception as e:
            print("Booking table load error:", e)

# ==================== APPLICATION EXECUTION ====================

def main():
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()

